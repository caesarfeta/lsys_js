/**
 * @author AdamTavares / http://adamtavares.com
*/
var LSYS = LSYS || { REVISION: '1' }

/**
 * The L-System generator
*/	
LSYS.Sys = function( _iter, _angle, _start ) {
	this.iter = _iter;			// {int} The total number of iterations.
	this.angle = _angle;		// {float} The angle.
	this.start = _start;		// {string} The starting state
	this.rules = {};			// {object} The rules of the L-System. 
	//------------------------------------------------------------
	//	Generated by the program
	//------------------------------------------------------------
	this.n = 0;					// {int}  The current iteration.
	this.output = this.start;	// {string} The string which becomes a output with the help of a renderer
	//------------------------------------------------------------
	//	Everything after the 3rd parameter is a rule
	//------------------------------------------------------------
	for ( var i=3; i<arguments.length; i++ ) {
		var map = arguments[i].split('=');
		this.rules[map[0]] = map[1];
	}
}

LSYS.Sys.prototype.draw = function( _renderer, _color ) {
	_renderer.draw( this.output, this.angle );
	var self = this;
	var timer;
	window.addEventListener( 'resize', function( _event ) {
		timer && clearTimeout( timer );
		timer = setTimeout( function() { 
			_renderer.reset( self ); 
		}, 100 );
	});
}

LSYS.Sys.prototype.run = function() {
	while( this.n < this.iter ) {
		this.next();
		this.n++;
	}
}

LSYS.Sys.prototype.next = function() {
	//------------------------------------------------------------
	//	Apply next rule
	//------------------------------------------------------------
	var chars = this.output.split('');
	for ( var i in chars ) {
		if ( chars[i] in this.rules ) {
			chars[i] = this.rules[ chars[i] ];
		}
	}
	this.output = chars.join('');
}

LSYS.Renderer = function( _canvas ) {
	this.canvas = _canvas;
	this.constants = {
		'+': 'COUNTERCLOCK',
		'-': 'CLOCKWISE',
		'[': 'PUSH',
		']': 'POP',
		'C': 'COLOR'
	};
	this.i = 1;
}

//------------------------------------------------------------
//	2D renderer class
//------------------------------------------------------------
LSYS.TwoD = function( _canvas, _options ){
	LSYS.Renderer.call( this, _canvas );
	this.ctx = this.canvas.getContext('2d');
	this.options = ( _options == undefined ) ? {} : _options;
	this.options['delay'] = ( this.options['delay'] == undefined ) ? 0 : this.options['delay'];
}

LSYS.TwoD.prototype = Object.create( LSYS.Renderer.prototype );

LSYS.TwoD.prototype.reset = function( _this ) {
	var self = _this;
	self.ctx.clearRect(0,0,self.canvas.width,self.canvas.height);
	self.draw( self.output, self.angle, true );
}

LSYS.TwoD.prototype.draw = function( _input, _angle, _reset ) {
	var self = this;
	_reset = ( _reset == undefined ) ? false : true;
	//------------------------------------------------------------
	//	Get the coordinates with unit distance
	//------------------------------------------------------------
	var angle = _angle;
	var x = 0;
	var y = 0;
	var maxX = 0;
	var maxY = 0;
	var minX = 0;
	var minY = 0;
	coords = [];
	coords.push( [x,y] );
	//------------------------------------------------------------
	//	Loop through the LSys input string
	//------------------------------------------------------------
	var chars = _input.split('');
	for ( var i in chars ) {
		if ( chars[i] in this.constants ) {
			switch ( this.constants[ chars[i] ] ) {
				case 'COUNTERCLOCK':
					angle += _angle;
					break;
				case 'CLOCKWISE':
					angle -= _angle;
					break;
			}
		}
		else {
			var vector = Math.toCart( 1, Math.toRad( angle ) );
			x += vector[0];
			y += vector[1];
			coords.push( [x,y] );
			
			//------------------------------------------------------------
			//	Keep track of the biggest and smallest coordinates so 
			//	we can determine the boundary box of the image
			//------------------------------------------------------------
			maxX = ( x > maxX ) ? x : maxX;
			maxY = ( y > maxY ) ? y : maxY;
			minX = ( x < minX ) ? x : minX;
			minY = ( y < minY ) ? y : minY;
		}
	}
	//------------------------------------------------------------
	//	Get the values you need to nudge the shape in place
	//------------------------------------------------------------
	var nudgeX = ( minX < 0 ) ? minX*-1 : 0;
	var nudgeY = ( minY < 0 ) ? minY*-1 : 0;	
	//------------------------------------------------------------
	//	Scale the thing up to the size of the canvas
	//------------------------------------------------------------
	var rx = this.canvas.width / ( maxX + nudgeX );
	var ry = this.canvas.height / ( maxY + nudgeY );
	var scale = ( rx < ry ) ? rx : ry;
	//------------------------------------------------------------
	//	Center the shape into the center of the canvas
	//------------------------------------------------------------
	var centerX = this.canvas.width / 2;
	//------------------------------------------------------------
	//	Draw the thing to the canvas
	//------------------------------------------------------------
	if ( _reset == true ) {
		var i=0;
		while ( i < self.i ) {
			self.toCanvas( coords, i, scale, centerX, nudgeY );
			i++;
		}
	}
	
	self.interval = setInterval( function() {
		if ( self.i > coords.length ) {
			clearInterval( self.interval );
			self.i = 1;
			return;
		}
		self.toCanvas( coords, self.i, scale, centerX, nudgeY );
		self.i++;
	}, self.options['delay']*1000 );
}

LSYS.TwoD.prototype.toCanvas = function( _coords, _i, _scale, _centerX, _nudgeY ) {
	var self = this;
	self.ctx.beginPath();
	self.ctx.moveTo( (_coords[ _i-1 ][0])*_scale + _centerX, (_coords[ _i-1 ][1]+_nudgeY)*_scale);
	self.ctx.lineTo( (_coords[ _i ][0])*_scale + _centerX, (coords[ _i ][1]+_nudgeY)*_scale);
	self.ctx.stroke();
	self.ctx.closePath();
	self.ctx.stroke();
}
//------------------------------------------------------------
//	3D renderer class
//------------------------------------------------------------
LSYS.ThreeD = function(){
	return {
		draw: function( _input, _angle ) {}
	}
}
LSYS.ThreeD.prototype = Object.create( LSYS.Renderer.prototype );

LSYS.ThreeD.draw = function() {
	
}

//------------------------------------------------------------
//	Library
//------------------------------------------------------------
LSYS.DragonCurve = function( _canvas ) {
	LSYS.TwoD.call( this, _canvas, { 'delay': .001 } );
	var sys = new LSYS.Sys( 12, 90, 'FX', 'X=X+YF+', 'Y=-FX-Y' );
	sys.run();
	sys.draw( this );
}

LSYS.DragonCurve.prototype = Object.create( LSYS.TwoD.prototype );;

LSYS.HexagonSierpinski = function( _canvas ) {
	LSYS.TwoD.call( this, _canvas, { 'delay': .001, 'colors': ['#FF0000','#0000FF'] } );
	var sys = new LSYS.Sys( 10, 60, 'A', 'A=B-A-B', 'B=A+B+A' );
	sys.run();
	sys.draw( this );
}

LSYS.HexagonSierpinski.prototype = Object.create( LSYS.TwoD.prototype );;

//------------------------------------------------------------
//	Some handy math functions
//------------------------------------------------------------
Math.toRad = function( _degrees ) {
	return _degrees*Math.PI / 180;
}

Math.toCart = function( _radius, _angle ) {
	return [ _radius*Math.cos( _angle ), _radius*Math.sin( _angle ) ];
}